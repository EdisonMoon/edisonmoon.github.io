[{"content":" 拍摄时间：2023/04/15\n郁金香 Charming Beauty Tom Pouce purple jacket Marilyn 牡丹 风信子 葡萄风信子 银杏 ","permalink":"https://edinik.com/posts/life/beijing-zhongshan-park-2023-tulips-peonies/","summary":"拍摄时间：2023/04/15 郁金香 Charming Beauty Tom Pouce purple jacket Marilyn 牡丹 风信子 葡萄风信子 银杏","title":"摄影集 | 中山公园 郁金香 牡丹"},{"content":" 英文名：Tulipa gesneriana /tuːlɪpə ɡɛsˈnɛriənə/\n目 科 属 种 百合目 百合科 郁金香属 郁金香 Single Tulips 单瓣郁金香 1、Christmas Marvel 圣诞奇迹 2、Prince of Austria 奥地利王子 3、Diana 戴安娜 4、Ruby Red 红宝石 5、General De Wet 德韦特将军 6、Dreamland 梦幻之地 7、Prins Carnaval 狂欢节王子 8、Red Georgette 红色乔其纱 9、Christmas Pearl 圣诞珍珠 10、Purple Prince 紫色王子 Double Tulips 重瓣组 型似芍药，花朵可达25cm\n1、Abba 阿巴乐队 2、Montreux 蒙特勒 3、Black Hero 黑色英雄 4、Ice Cream 冰淇淋 5、Verona 维罗纳 6、Monte Carlo 蒙特卡洛 7、Peach Blossom Fosteriana Tulips 福斯特组 碗型大花瓣,复花性很好\n1、Orange Emperor 橙色皇帝 2、Exotic Emperor 异国情调 Kaufmanniana Tulips 考夫曼组 星星杯型，身材小巧\n1、Jeantine 2、Giuseppe Verdi 朱塞佩·威尔第 Darwin Hybrid 达尔文组 高大强壮，连续多年复花\n1、Parade 巡游 2、Pink impression 3、Golden Apeldoorn 阿珀尔登金 Greigii Tulips 格里吉组 单瓣碗型，叶子有条纹\n1、Calypso 卡吕普索 2、Winnipeg 温尼伯 Fringed Tulips 花边组 花瓣有流苏花边，花期、身高各异\n1、Blue Heron 蓝鹭 2、Huis Ten Bosch 豪斯登堡 3、Brest 布雷斯特 Triumph Tulips 凯旋组 品种最多，中等身材，花茎坚挺\n1、Oscar 奥斯卡 2、Mistress Mystic 3、White Dream 白色梦境 4、Shirley 雪莉 Parrot Tulips 鹦鹉 毛边大花瓣，晚花\n1、Rococo 洛可可 2、Flaming 火焰 3、Super 4、Apricot 5、Green wave 6、Texas Flame Lily-Flowered 百合花组 高脚杯型，花茎纤细\n1、Aladdin 2、West Point 3、Maytime 4、White Triumphator 5、Ballade 6、Marilyn Viridiflora Tulips 绿花组 花瓣中间带绿色条纹\n1、Golden Artist 2、China town 3、Sprint Green 4、Florosa 5、Artist 参考资料 [1] Tulip - Wikipedia\n","permalink":"https://edinik.com/posts/life/introduction-to-tulips/","summary":"英文名：Tulipa gesneriana /tuːlɪpə ɡɛsˈnɛriənə/ 目 科 属 种 百合目 百合科 郁金香属 郁金香 Single Tulips 单瓣郁金香 1、Christmas Marvel 圣诞奇迹 2、Prince of Austria 奥地利王子 3、Diana 戴安娜 4、Ruby Red 红宝石 5、General De Wet 德韦特将军 6、Dreamland 梦幻之地 7、P","title":"鲜花百科 | 郁金香"},{"content":"庭院深深深几许，杨柳堆烟，帘幕无重数。玉勒雕鞍游冶处，楼高不见章台路。 雨横风狂三月暮，门掩黄昏，无计留春住。泪眼问花花不语，乱红飞过秋千去。\n赏析：\n首先对女主人公的居处作了精心的安排。读着“杨柳堆烟，帘幕无重数”，仿佛先是看到一丛丛杨柳从眼前移过，随着这一丛丛杨柳过去，镜头摇向庭院，摇向帘幕。这帘幕不是一重，而是过了一重又是一重，令人感到这座庭院简直是无比幽深。但是画面并没有切到女主人公所在的地点。先说一句“玉勒琱鞍游冶处”，宕开一笔，把视线引到了她丈夫那里。然后折过笔来写道，“楼高不见章台路”。原来词中女子正独处高楼，她的目光正透过重重帘幕，堆堆柳烟，向丈夫经常游冶的地方凝神远望。\n雨横风狂，催送着残春，也催送着女主人公的芳年。她想挽留住春天，但风雨无情，留春不住。于是她感到无奈，只好把感情寄托到命运同她一样的花上：“泪眼问花花不语，乱红飞过秋千去”。人儿走马章台，花儿飞过秋千，有情之人，无情之物对她都报以冷漠，可见词中女子的心境。\n","permalink":"https://edinik.com/posts/read/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D-%E8%9D%B6%E6%81%8B%E8%8A%B1-%E5%BA%AD%E9%99%A2%E6%B7%B1%E6%B7%B1%E6%B7%B1%E5%87%A0%E8%AE%B8/","summary":"庭院深深深几许，杨柳堆烟，帘幕无重数。玉勒雕鞍游冶处，楼高不见章台路。 雨横风狂三月暮，门掩黄昏，无计留春住。泪眼问花花不语，乱红飞过秋千去。 赏析： 首先对女主人公的居处作了精心的安排。读着“杨柳堆烟，帘幕无重数”，仿佛先是看到一丛丛杨柳从眼前移过，随着这一丛丛杨柳过去，镜头摇向庭院","title":"人间词话 | 蝶恋花-庭院深深深几许"},{"content":"引言 设计模式是软件设计中常见问题的典型解决方案。它们就像能根据需求进行调整的预制蓝图，可用于解决代码中反复出现的设计问题。\n创建型模式 提供创建对象的机制， 增加已有代码的灵活性和可复用性。\n1、单例模式 英文表述：Singleton /ˈsɪŋɡltən/\n能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。\n2、工厂方法模式 英文表述：Factory Method /ˈfæktri/ /ˈmeθəd/\n在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。\n3、抽象工厂模式 英文表述：Abstract Factory /ˈæbstrækt/ /ˈfæktri/\n能创建一系列相关的对象， 而无需指定其具体类。\n4、建造者模式 英文表述：Builder /ˈbɪldə(r)/\n能够分步骤创建复杂对象。允许使用相同的创建代码生成不同类型和形式的对象。\n5、原型模式 英文表述：Prototype /ˈprəʊtətaɪp/\n能够复制已有对象， 而又无需使代码依赖它们所属的类。\n结构型模式 将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。\n1、适配器模式 英文表述：Adapter /əˈdæptə(r)/\n使接口不兼容的对象能够相互合作。\n2、桥接模式 英文表述：Bridge /brɪdʒ/\n可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。\n3、组合模式 英文表述：Composite /ˈkɒmpəzɪt/\n允许将对象组合成树形结构， 并且能像使用独立对象一样使用它们。\n4、装饰模式 英文表述：Decorator /ˈdekəreɪtə(r)/\n允许将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。\n5、外观模式 英文表述：Facade /fəˈsɑːd/\n为程序库、 框架或其他复杂类提供一个简单的接口。\n6、享元模式 英文表述：Flyweight /ˈflaɪweɪt/\n摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，能在有限的内存容量中载入更多对象。\n7、代理模式 英文表述：Proxy /ˈprɒksi/\n能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。\n行为型模式 负责对象间的高效沟通和职责委派。\n1、职责链模式 英文表述：Chain of Responsibility /ˈtʃeɪn/ /əv/ /rɪˌspɒnsəˈbɪləti/\n允许将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。\n2、命令模式 英文表述：Command /kəˈmɑːnd/\n可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。\n3、迭代器模式 英文表述：Iterator /ˈɪtəreɪtə(r)/\n能在不暴露集合底层表现形式（列表、栈和树等）的情况下遍历集合中所有的元素。\n4、中介者模式 英文表述：Mediator /ˈmiː.di.eɪ.t̬ɚ/\n能减少对象之间混乱无序的依赖关系。会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作。\n5、备忘录模式 英文表述：Memento /məˈmentəʊ/\n允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。\n6、观察者模式 英文表述：Observer /əbˈzɜːvə(r)/\n允许定义一种订阅机制，可在对象事件发生时通知多个 “观察” 该对象的其他对象。\n7、状态模式 英文表述：State /steɪt/\n能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样。\n8、策略模式 英文表述：Strategy /ˈstrætədʒi/\n能定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。\n9、模板方法模式 英文表述：Template Method /ˈtempleɪt/ /ˈmeθəd/\n在超类中定义了一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。\n10、访问者模式 英文表述：Visitor /ˈvɪzɪtə(r)/\n能将算法与其所作用的对象隔离开来。\n11、解释器模式 英文表述：Interpreter /ɪnˈtɜːprətə(r)/\n可以将复杂的语言转化为易于处理的数据结构，从而使得语言的解释更加容易。\n参考资料 [1] refactoringguru-design-patterns\n","permalink":"https://edinik.com/posts/tech/design-pattern-introduction/","summary":"引言 设计模式是软件设计中常见问题的典型解决方案。它们就像能根据需求进行调整的预制蓝图，可用于解决代码中反复出现的设计问题。 创建型模式 提供创建对象的机制， 增加已有代码的灵活性和可复用性。 1、单例模式 英文表述：Singleton /ˈsɪŋɡltən/ 能够保证一个类只有一个实例，并提供","title":"设计模式 | 简介"},{"content":"解析域名 准备两个域名并在Cloudflare解析域名到服务器IP：\n域名1：开启CDN，用于访问前端页面，如：\u0026ldquo;https://cdn.example.com\u0026rdquo; 域名2：不开启CDN，用于Agent访问后端API，如：\u0026ldquo;https://api.example.com\u0026rdquo; 获取Github的Client ID和Client Secret 登录Github，点击右上角头像，选择Settings， 点击Developer settings，点击New OAuth App 填写注册信息： Application name - 随意填写，如：\u0026ldquo;nezha-monitoring\u0026rdquo; Homepage URL - 填写面板的访问域名，如：\u0026ldquo;https://cdn.example.com\u0026rdquo; Authorization callback URL - 填写回调地址，如：\u0026ldquo;https://cdn.example.com/oauth2/callback\u0026quot; 点击Register application 保存页面中的 Client ID，然后点击 “Generate a new client secret“，创建一个新的 Client Secret，新建的密钥仅会显示一次，请妥善保存 在服务器中安装 Dashboard 在面板服务器中，运行安装脚本：\ncurl -L https://raw.githubusercontent.com/naiba/nezha/master/script/install.sh -o nezha.sh \u0026amp;\u0026amp; chmod +x nezha.sh \u0026amp;\u0026amp; sudo ./nezha.sh 等待Docker安装完毕后，分别输入以下值：\nOAuth提供商：Github Client ID - 之前保存的 Client ID Client Secret - 之前保存的密钥 用户名 - OAuth 提供商中的用户名 站点标题 - 自定义站点标题 访问端口 - 公开访问端口，可自定义，默认 8008 Agent的通信端口 - Agent与Dashboard的通信端口，默认 5555 输入完成后，等待拉取镜像。\n将来如果需要再次运行脚本，可以运行：\n./nezha.sh 开启反向代理和SSL 通过宝塔界面分别对两个域名配置反向代理和SSL，配置完成后，访问面板域名，即可看到面板。\n配置未接入CDN的域名 后台管理 - 设置 - 未接入CDN的面板服务器域名/IP：输入未接入CDN的域名，如：\u0026ldquo;https://api.example.com\u0026rdquo; 安装Agent 首先在管理面板中添加一台服务器 点击新添加的服务器旁，绿色的 Linux 图标按钮，复制一键安装命令 在被控端服务器中运行复制的一键安装命令，等待安装完成后返回到 Dashboard 主页查看服务器是否上线 参考资料 哪吒监控官方文档 ","permalink":"https://edinik.com/posts/tech/nezha-monitoring-server-build/","summary":"解析域名 准备两个域名并在Cloudflare解析域名到服务器IP： 域名1：开启CDN，用于访问前端页面，如：\u0026ldquo;https://cdn.example.com\u0026rdquo; 域名2：不开启CDN，用于Agent访问后端API，如：\u0026ldquo;https://api.ex","title":"哪吒监控 | 服务端搭建"},{"content":"\u003c!DOCTYPE HTML\u003e EP 34\n长球和短球 观察对方发球的第一个落点，如果比较靠近台内的话，就是短球，如果比较靠近台外的话，就是长球。\n旋转的判断 旋转球 在对方球拍接触球时的一刹那，观察发力方向。\n如果接触球时，没有发力摩擦，只是碰过来的，那么就是没有加转的球。 如果接触球时，有发力摩擦，那么就是有加转的球。 侧旋球 三个特征：\n1、看发力方向：\n往上发力，则侧上旋 往下发力，则侧下旋 2、看第一个落点之后的弧线：\n有点往上蹦，弧线比较高的为侧上旋 贴着台面运行，弧线比较低的为侧下旋 3、看到己方台面落点之后的弧线：\n往上蹦的为侧上旋 往下走的为侧下旋 策略 1、上策：\n积极主动，先上手为主 2、中策：\n控制对手，用摆短制约对手打发球抢攻，不让对手抢先上手 3、下策：\n主动劈长，对方轻拉之后，再来衔接第二板的反冲，主动去防守 注意事项 接正手位短球时，上半身的重心要保持稳定，下半身的重心要提起来，脚后跟抬起。这样拉球可以抢到高点，搓球时也有空间可以能控制住球。 在接短球的时候，手不能低，否则球容易冒高。重心要插到台子里。 接发球时要根据来球灵活调整步法，对方发短球可以通过并步上台内接。对方发长球，可以用小碎步往后退，找到最佳位置从容出手。 在接发球练习中，步法站位不要定在一点，短球可以上，长球也可以下。 对方发来长球之后，自己要在步法上做出调整，往后退半步再出手，才能充分发力。 接发球时如果判断准确了，等好的球就可以下手凶一点，等不好的球还是以稳为主。 ","permalink":"https://edinik.com/posts/life/table-tennis-serve-receive/","summary":"\u003c!DOCTYPE HTML\u003e EP 34 长球和短球 观察对方发球的第一个落点，如果比较靠近台内的话，就是短球，如果比较靠近台外的话，就是长球。 旋转的判断 旋转球 在对方球拍接触球时的一刹那，观察发力方向。 如果接触球时，没有发力摩擦，只是碰过来的，那么就是没有加转的球。 如果接触球时，有发力摩擦，那么就是有加转的球。 侧旋","title":"乒乓球 | 接发球"},{"content":"云服务器/VPS 的配置 1、方式一：使用一键脚本安装 缺点：无法自定义配置，只能使用脚本默认设置\n1、推荐非host模式下执行以下脚本（可以共享主机端口）\nhost模式无法映射docker端口到主机 非host模式下会将docker的80端口映射到主机的8443端口\n# 非host模式安装 bash -c \u0026#34;$(curl -s http://docker.xiaoya.pro/update_new.sh)\u0026#34; # host模式安装 bash -c \u0026#34;$(curl -s http://docker.xiaoya.pro/update_new.sh)\u0026#34; -s host 2、输入阿里云盘的Token\n阿里云盘的Token获取教程\n3、输入阿里云盘Open的Token\n阿里云盘Open的Token获取教程\n4、设置转存目录ID\n打开阿里云盘 进入转存目录 拷贝地址栏中fold/后一串ID 5、设置强制登录\n也可以通过vim等编辑器创建一个guestlogin.txt文件，内容可为空 若需要取消强制登录，则可以删除guestlogin.txt文件\ntouch /etc/xiaoya/guestlogin.txt 6、设置自定义密码\n默认用户名：dav\nvim /etc/xiaoya/guestpass.txt 在guestpass.txt文件中输入自定义密码，最好不要包含特殊字符\n7、重启docker\nsudo systemctl restart docker 8、通过Cloudfare或其它DNS解析服务将域名解析到服务器\n9、通过宝塔界面将域名反代到8443端口，并开启https\n10、访问域名即可\n网站需要对资源进行索引，大概会持续十几分钟\n2、方式二：手动安装 1、拉取xiaoya的docker\nrm -rf /etc/xiaoyaAlist/mytoken.txt # 删除旧的token文件 mkdir -p /etc/xiaoyaAlist # 创建配置文件夹 touch /etc/xiaoyaAlist/guestlogin.txt # 创建强制登录文件，若不需要强制登录则不创建该文件 touch /etc/xiaoyaAlist/guestpass.txt # 创建自定义密码文件 touch /etc/xiaoyaAlist/mytoken.txt # 创建token文件 touch /etc/xiaoyaAlist/myopentoken.txt # 创建open token文件 touch /etc/xiaoyaAlist/temp_transfer_folder_id.txt # 创建转存目录ID文件 # 格式：\u0026#34;xxxxxxxx\u0026#34; \u0026#34;yyyyyyyy\u0026#34; 账号可以是邮箱和手机号，手机号前面要加区号，也就是 \u0026#34;+86xxxx\u0026#34; 这样，注册如果用谷歌快捷方式登入的话是无法使用谷歌邮箱登入的（alist不支持） touch /etc/xiaoyaAlist/pikpak.txt touch /etc/xiaoyaAlist/show_my_ali.txt # 通过此文件的存在与否来决定是否加载自己的阿里云盘，若不需要加载则不创建该文件 # 配合 TVBOX的alist搜索，配置地址 https://你的域名/tvbox/my.json，格式：https://你的域名 （最后不要加 /) touch /etc/xiaoyaAlist/docker_address.txt # 挂载自己一个或多个 pikpak账号，挂载名 \u0026#34;账号\u0026#34; \u0026#34;密码\u0026#34; ，用空格分开（pikpak2 “abc@hotmail.com\u0026#34; \u0026#34;123456\u0026#34;），每行一个 挂载名不能有空格 touch /etc/xiaoyaAlist/pikpak_list.txt # 挂载自己一个或多个 pikpak分享 格式：挂载名 分享ID 分享目录 ，用空格分开（赵霸道 VNRT8Wr8BGyw1kt1HkijKR4Qo1 VNQf6ZmWE3pVWGpuFriGqyPzo1），每行一个 挂载名不能有空格 touch /etc/xiaoyaAlist/pikpakshare_list.txt # 挂载自定义分享ID 格式：挂载名 阿里分享ID(/folder前) 文件folder id(/folder后)，用空格分开，每行一个 (120T电影资源 ZpevUcDZ2Pn 636c8ba0703acd24cd44b19dd00312ef15b1e8) 挂载名不能有空格 touch /etc/xiaoyaAlist/pikpakshare_list.txt docker stop xiaoyaAlist # 停止旧的docker docker rm xiaoyaAlist # 删除旧的docker docker pull xiaoyaliu/alist:latest # 拉取最新的docker # 将配置文件夹/etc/xiaoyaAlist挂载到docker内部的/data文件夹,将docker的80端口映射到主机的8888端口,设置自动重启,设置docker名称为xiaoyaAlist,并启动docker docker run -d -p 8888:80 -v /etc/xiaoyaAlist:/data --restart=always --name=xiaoyaAlist xiaoyaliu/alist:latest 2、设置阿里云盘Token\n阿里云盘的Token获取教程\nvim /etc/xiaoyaAlist/mytoken.txt 3、设置阿里云盘Open Token\n阿里云盘Open的Token获取教程\nvim /etc/xiaoyaAlist/myopentoken.txt 4、设置转存目录ID\n打开阿里云盘 进入转存目录 拷贝地址栏中fold/后一串ID vim /etc/xiaoyaAlist/temp_transfer_folder_id.txt 5、设置自定义密码\n默认用户名：dav\nvim /etc/xiaoyaAlist/guestpass.txt 在guestpass.txt文件中输入自定义密码，最好不要包含特殊字符\n6、重启docker\nsudo systemctl restart docker 7、通过Cloudfare或其它DNS解析服务将域名解析到服务器\n8、通过宝塔界面将域名反代到8443端口，并开启https\n9、访问域名即可\n网站需要对资源进行索引，大概会持续十几分钟\n定时与网站同步数据 crontab -e 0 6 * * * docker restart xiaoya 如何使用 1、potplayer 2、nplayer 参考资料 [1] 如何设置xiaoya的docker [2] AList文档\n","permalink":"https://edinik.com/posts/tech/build-online-player-alist/","summary":"云服务器/VPS 的配置 1、方式一：使用一键脚本安装 缺点：无法自定义配置，只能使用脚本默认设置 1、推荐非host模式下执行以下脚本（可以共享主机端口） host模式无法映射docker端口到主机 非host模式下会将docker的80端口映射到主机的8443端口 # 非host模式安装 bash -c","title":"Alist | 在线播放服务搭建"},{"content":"宝塔面板的安装 安装宝塔界面最好全新系统安装\nDebian wget -O install.sh https://download.bt.cn/install/install-ubuntu_6.0.sh \u0026amp;\u0026amp; bash install.sh ed8484bec Ubuntu/Deepin wget -O install.sh https://download.bt.cn/install/install-ubuntu_6.0.sh \u0026amp;\u0026amp; sudo bash install.sh ed8484bec CentOS yum install -y wget \u0026amp;\u0026amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh \u0026amp;\u0026amp; sh install.sh ed8484bec nginx的安装 软件商店 -\u0026gt; Nginx -\u0026gt; 安装 docker的安装 软件商店 -\u0026gt; Docker -\u0026gt; 安装 域名解析 通过Cloudfare或其他DNS服务商解析域名到服务器IP vaultwarden的安装 不要使用默认的ADMIN_TOKEN，务必修改为一个随机的密码\ndocker run -d --restart always --name vaultwarden -e TZ=Asia/Shanghai -e ADMIN_TOKEN=some_random_token -v /vaultwarden-data/:/data/ -p 8443:80 vaultwarden/server:latest -d：指定容器运行于前台或者后台（默认为 false 表示后台） \u0026ndash;restart always：自动启动（在宿主机重启后或者 Docker 服务重启后） \u0026ndash;name vaultwarden：指定容器名称为 vaultwarden -e TZ=Asia/Shanghai：设置时区 -e LOG_FILE=/data/log/vaultwarden.log：设置日志文件路径 -e ADMIN_TOKEN=some_random_token：设置 ADMIN_TOKEN 环境变量以启用管理页面 -v /vaultwarden-data/:/data/：挂载容器的 data 目录到宿主机的 vaultwarden-data 目录上 -p 8443:80：指定容器的 80 端口暴露在宿主机的 8443 端口上 vaultwarden的配置 配置完反向代理和SSL证书后，需要重启Nginx\n1、通过宝塔面板配置反向代理 站点 -\u0026gt; 添加站点 -\u0026gt; 反向代理 -\u0026gt; 映射8443端口到域名 2、通过宝塔面板配置SSL证书 站点 -\u0026gt; 站点管理 -\u0026gt; 证书 -\u0026gt; 申请证书 -\u0026gt; 选择域名 -\u0026gt; 选择证书类型 -\u0026gt; 提交申请 3、管理界面 地址：https://域名/admin 密码：ADMIN_TOKEN字段设置的值 禁止新用户注册：\nAllow new signups：false 注册新用户：\nUsers-\u0026gt;Invite User-\u0026gt;输入邮箱 浏览器输入域名-\u0026gt;进入登录界面-\u0026gt;注册 更新vaultwarden 1、拉取最新版本的稳定版镜像\n# 拉取最新版本的稳定版镜像 docker pull vaultwarden/server:latest 2、停止旧版本容器\n# 停止旧版本容器 docker stop vaultwarden 3、移除旧版本容器\n# 移除旧版本容器 docker rm vaultwarden 4、使用已挂载的数据创建新的容器\n注意修改ADMIN_TOKEN的值\n# 使用已挂载的数据创建新的容器 docker run -d --restart always --name vaultwarden -e TZ=Asia/Shanghai -e ADMIN_TOKEN=some_random_token -v /vaultwarden-data/:/data/ -p 8443:80 vaultwarden/server:latest 自动备份数据 1、创建 Dropbox 应用 登录 Dropbox 后，打开 App Console 页面，点击 Create app 按钮创建一个 App Choose an API → 勾选 Scoped access Choose the type of access you need → 选择 App folder Name your app → 输入 App 名称（必须是不存在的名称，已存在会有提示已被占用），此名称会作为 Dropbox 上此 App 可读写的文件夹名称 创建成功后，进入应用 在 Permissions 选项卡下的 Files and folders 部分，勾选Files.metadata.write、Files.metadata.read、Files.content.write、Files.content.read四个权限, 点击页面下方Submit 按钮保存 2、上传并配置脚本 SSH 定位到 VPS 的 root 目录，下载 dropbox_uploader.sh 脚本文件并赋予可执行权限，然后运行脚本：\nwget https://raw.github.com/andreafabrizi/Dropbox-Uploader/master/dropbox_uploader.sh chmod +x dropbox_uploader.sh # 赋予可执行权限 ./dropbox_uploader.sh # 运行此脚本配置 access token 输入App key 输入App secret 点击认证链接，登录 Dropbox 账号并授权，获取访问码 输入访问码 修改访问码：\nvim .dropbox_uploader 3、创建自己的备份脚本 vim /root/vaultwarden-data_backup.sh 复制并粘帖如下内容：\n# 这个改成你存放刚刚下载下来的 dropbox_uploader.sh 的文件夹位置 SCRIPT_DIR=\u0026#34;/root\u0026#34; # 这个改成你的备份文件想要放在 Dropbox 上的文件夹名称，如果不存在，脚本会自动创建 BACK_DIR=\u0026#34;/vaultwarden-data\u0026#34; # 这个是你想要备份的本地 VPS 上的文件夹，不同的目录用空格分开 BACKUP_SRC=\u0026#34;/vaultwarden-data\u0026#34; # 这个是你暂时存放备份压缩文件的地方，这里我们放在 /tmp/vaultwarden-data-backup 下 BACKUP_DST=\u0026#34;tmp/vaultwarden-data-backup\u0026#34; # 定义备份文件的名称 ## 定义当前日期的备份文件 BACKUP_FILE=vaultwarden-data_$(date +\u0026#34;%Y-%m-%d\u0026#34;).tar.gz ## 定义 6 天前的备份文件 OLD_BACKUP_FILE_6=vaultwarden-data_$(date -d -6day +\u0026#34;%Y-%m-%d\u0026#34;).tar.gz ## 定义 15 天前的备份文件 OLD_BACKUP_FILE_15=vaultwarden-data_$(date -d -15day +\u0026#34;%Y-%m-%d\u0026#34;).tar.gz # 删除 VPS 上 6 天前的备份文件 rm -rf \u0026#34;$BACKUP_DST/$OLD_BACKUP_FILE_6\u0026#34; # 对备份文件夹进行压缩打包 tar zcf \u0026#34;$BACKUP_DST/$BACKUP_FILE\u0026#34; $BACKUP_SRC # 上传备份文件到 Dropbox $SCRIPT_DIR/dropbox_uploader.sh upload \u0026#34;$BACKUP_DST/$BACKUP_FILE\u0026#34; \u0026#34;$BACK_DIR/$BACKUP_FILE\u0026#34; # 删除 Dropbox 上 15 天前的备份文件 $SCRIPT_DIR/dropbox_uploader.sh delete \u0026#34;$BACK_DIR/$OLD_BACKUP_FILE_15\u0026#34; 赋予可执行权限：\nchmod +x /root/vaultwarden-data_backup.sh 创建备份文件夹：\ncd ~ mkdir tmp cd tmp mkdir vaultwarden-data-backup 输入 ./vaultwarden-data_backup.sh 手动执行脚本，以测试能否成功备份。\n4、创建自动执行任务 crontab -e # 打开定时任务 0 4 * * * /root/vaultwarden-data_backup.sh # 添加一行新任务：每天凌晨 4 点自动执行此脚本 service crond restart # 重启定时任务 日志转储 如果你想保留日志记录，又不希望日志记录文件变得越来越大，可以设置定期转储日志记录。\n创建日志转储规则文件：\nvim /etc/logrotate.d/vaultwarden 复制并粘帖如下内容：\n# 其他配置项使用 logrotate 配置文件 /etc/logrotate.conf 中的默认值 /vaultwarden-data/log/vaultwarden.log { daily rotate 30 missingok copytruncate noolddir dateext postrotate find /vaultwarden-data/log/ -name vaultwarden.log\u0026#34;-`(date +%Y%m%d)`\u0026#34; -exec mv {} /vaultwarden-data/log/vaultwarden\u0026#34;-`(date +%Y%m%d)`\u0026#34;.log \\; endscript } 这里设置为每天转储一次（如果日志记录比较少也可以设置为每周或每月），并保留 30 个转储的日志记录文件。\n配置解释：\ndaily：daily 指定转储周期为每天。也可以为 weekly/monthly 。默认为 weekly。 rotate 30：表示转储备份的数量。这里为 30 个。 missingok：在日志转储期间，任何错误将被忽略。 copytruncate：用于还在打开中的日志文件。把当前日志截断并备份，然后再清空。由于备份和清空之间有一个时间差，可能会丢失部分日志数据。 noolddir：转储后的日志文件和当前日志文件放在同一个目录下。 dateext：指定转储后的日志文件以当前日期格式结尾。如 vaultwarden.log-20201020。 postrotate/endscript：在转储之后需要执行的命令可以放入这个语句对中，这两个关键字必须单独成行。同样，prerotate/endscript 表示在转储之前需要执行的命令。 参考资料 宝塔面板官方网站 Vaultwarden部署和使用 ","permalink":"https://edinik.com/posts/tech/establishing-bitwarden-server/","summary":"宝塔面板的安装 安装宝塔界面最好全新系统安装 Debian wget -O install.sh https://download.bt.cn/install/install-ubuntu_6.0.sh \u0026amp;\u0026amp; bash install.sh ed8484bec Ubuntu/Deepin wget -O install.sh https://download.bt.cn/install/install-ubuntu_6.0.sh \u0026amp;\u0026amp; sudo bash install.sh ed8484bec CentOS yum install -y wget \u0026amp;\u0026amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh \u0026amp;\u0026amp; sh install.sh ed8484bec nginx的安装 软件商店 -\u0026gt; Nginx -\u0026gt; 安装 docker的安装 软件商店 -\u0026gt; Docker -\u0026gt; 安装 域名解析 通过Cloudfare或其他DNS服务商解析域名到服务器IP vaultwarden的安装 不要使","title":"vaultwarden  | 个人密码管理器搭建"},{"content":"一个节点 flowchart LR 北京 flowchart LR 北京 一个带文本的节点 flowchart LR 北京[北京是中国的首都] flowchart LR 北京[北京是中国的首都] 流程图方向 从左到右 flowchart LR 北京--\u0026gt;上海 flowchart LR 北京--\u003e上海 从右到左 flowchart RL 北京--\u0026gt;上海 flowchart RL 北京--\u003e上海 从上到下 flowchart TB 北京--\u0026gt;上海 flowchart TB 北京--\u003e上海 从下到上 flowchart BT 北京--\u0026gt;上海 flowchart BT 北京--\u003e上海 节点样式 圆角节点 flowchart LR 北京(北京是中国的首都) flowchart LR 北京(北京是中国的首都) 半圆弧节点 flowchart LR 开始([开始]) flowchart LR 开始([开始流程]) 子流程节点 flowchart LR 子流程[[这是一个子流程]] flowchart LR 子流程[[这是一个子流程]] 圆柱形节点 flowchart LR 数据库[(数据库)] flowchart LR 数据库[(数据库)] 圆形节点 flowchart LR 圆形((这是一个圆形)) flowchart LR 圆形((这是一个圆形)) 非对称形状节点 flowchart LR 非对称形状\u0026gt;这是一个非对称形状] flowchart LR 非对称形状\u003e这是一个非对称形状] 菱形节点 flowchart LR 菱形{这是一个菱形} flowchart LR 菱形{这是一个菱形} 六边形节点 flowchart LR 六边形{{这是一个六边形}} flowchart LR 六边形{{这是一个六边形}} 平行四边形节点 flowchart LR 平行四边形[/这是一个平行四边形/] flowchart LR 平行四边形[/这是一个平行四边形/] flowchart LR 平行四边形[\\这是一个平行四边形\\] flowchart LR 平行四边形[\\这是一个平行四边形\\] 梯形节点 flowchart LR 梯形[/这是一个梯形\\] flowchart LR 梯形[/这是一个梯形\\] flowchart LR 梯形[\\这是一个梯形/] flowchart LR 梯形[\\这是一个梯形/] 双重圆环节点 flowchart LR 双重圆环(((这是一个双重圆环))) flowchart LR 双重圆环(((这是一个双重圆环))) 节点之间的链接 带箭头的链接 flowchart LR 北京--\u0026gt;上海 flowchart LR 北京--\u003e上海 开放的链接 flowchart LR 北京---上海 flowchart LR 北京---上海 链接上的文字 flowchart LR 北京---|G30|上海 flowchart LR 北京---|G30|上海 带有箭头和文本的链接 flowchart LR 北京--\u0026gt;|G30|上海 flowchart LR 北京--\u003e|G30|上海 虚线链接 flowchart LR 北京-.-\u0026gt;上海 flowchart LR 北京-.-\u003e上海 带文本的虚线链接 flowchart LR 北京-.-\u0026gt;|G30|上海 flowchart LR 北京-.-\u003e|G30|上海 加粗链接 flowchart LR 北京==\u0026gt;上海 flowchart LR 北京==\u003e上海 带文本的加粗链接 flowchart LR 北京==\u0026gt;|G30|上海 flowchart LR 北京==\u003e|G30|上海 链式链接 flowchart LR 北京--\u0026gt;上海--\u0026gt;广州 flowchart LR 北京--\u003e|G30|上海--\u003e|G40|广州 flowchart LR 北京--\u0026gt;上海 \u0026amp; 杭州--\u0026gt;广州 flowchart LR 北京--\u003e上海 \u0026 杭州--\u003e广州 flowchart LR 上海 \u0026amp; 杭州--\u0026gt;广州 \u0026amp; 深圳 flowchart TB 上海 \u0026 杭州--\u003e广州 \u0026 深圳 新型箭头链接 flowchart LR 北京 --o 上海 --x 广州 flowchart LR 北京 --o 上海 --x 广州 双向箭头 flowchart LR 北京\u0026lt;--\u0026gt;上海o--o广州x--x深圳 flowchart LR 北京 \u003c--\u003e 上海 o--o 广州 x--x 深圳 链接的最小长度 flowchart TB A[开始] --\u0026gt; B[输入用户名和密码] B --\u0026gt; C{认证成功 ?} C --\u0026gt;|是| D[登录成功] C --\u0026gt;|否| E[登录失败] D --\u0026gt; F[进入系统] F ----\u0026gt; I E --\u0026gt; G{是否重新登录 ?} G --\u0026gt;|是| B G --\u0026gt;|否| H[退出系统] H --\u0026gt; I[结束] flowchart TB A[开始] --\u003e B[输入用户名和密码] B --\u003e C{认证成功 ?} C --\u003e|是| D[登录成功] C --\u003e|否| E[登录失败] D --\u003e F[进入系统] F ----\u003e I E --\u003e G{是否重新登录 ?} G --\u003e|是| B G --\u003e|否| H[退出系统] H --\u003e I[结束] 特殊字符 flowchart LR A[\u0026#34;这是一个(括号)字符\u0026#34;] flowchart LR A[\"这是一个(括号)字符\"] 转义字符的代码 flowchart LR A[\u0026#34;这是一个双引号:#quot;\u0026#34;] --\u0026gt; B[\u0026#34;这是一个单引号:#39;\u0026#34;] --\u0026gt; C[\u0026#34;这是一个爱心:#9829;\u0026#34;] flowchart LR A[\"这是一个双引号:#quot;\"] --\u003e B[\"这是一个单引号:#39;\"] --\u003e C[\"这是一个爱心:#9829;\"] 子图表 flowchart TB subgraph one[中国] c1[北京]--\u0026gt;c2[上海] end subgraph two[日本] b1[东京]--\u0026gt;b2[大阪] end subgraph three[美国] a1[纽约]--\u0026gt;a2[华盛顿] end a1--\u0026gt;c2 flowchart TB subgraph one[中国] c1[北京]--\u0026gt;c2[上海] end subgraph two[日本] b1[东京]--\u0026gt;b2[大阪] end subgraph three[美国] a1[纽约]--\u0026gt;a2[华盛顿] end a1--\u0026gt;c2 flowchart TB subgraph one[美国] a1[纽约]--\u0026gt;a2[华盛顿] end subgraph two[日本] b1[东京]--\u0026gt;b2[大阪] end subgraph three[中国] c1[北京]--\u0026gt;c2[上海] end c1--\u0026gt;a2 one--\u0026gt;two three--\u0026gt;two two--\u0026gt;c2 flowchart TB subgraph one[美国] a1[纽约]--\u0026gt;a2[华盛顿] end subgraph two[日本] b1[东京]--\u0026gt;b2[大阪] end subgraph three[中国] c1[北京]--\u0026gt;c2[上海] end c1--\u0026gt;a2 one--\u0026gt;two three--\u0026gt;two two--\u0026gt;c2 子图表中的方向 flowchart LR subgraph 10[中国] direction TB subgraph 11[北京] direction LR 111[东城区] 112[西城区] 113[朝阳区] 111--\u0026gt;112--\u0026gt;113 end subgraph 12[上海] direction TB 121[黄浦区] 122[徐汇区] 123[长宁区] 121--\u0026gt;122--\u0026gt;123 end end A[美国]--\u0026gt;10[中国] --\u0026gt;B[日本] 11 --\u0026gt; 12 flowchart LR subgraph 10[中国] direction TB subgraph 11[北京] direction LR 111[东城区] 112[西城区] 113[朝阳区] 111--\u0026gt;112--\u0026gt;113 end subgraph 12[上海] direction TB 121[黄浦区] 122[徐汇区] 123[长宁区] 121--\u0026gt;122--\u0026gt;123 end end A[美国]--\u0026gt;10[中国] --\u0026gt;B[日本] 11 --\u0026gt; 12 交互 flowchart LR A[Google] B[Github] C[Wikipedia] A--\u0026gt;B--\u0026gt;C click A \u0026#34;https://www.google.com\u0026#34; \u0026#34;google\u0026#34; click A href \u0026#34;https://www.google.com\u0026#34; \u0026#34;google\u0026#34; click B \u0026#34;https://www.github.com\u0026#34; \u0026#34;github\u0026#34; click B href \u0026#34;https://www.github.com\u0026#34; \u0026#34;github\u0026#34; click C \u0026#34;https://www.wikipedia.org\u0026#34; \u0026#34;wikipedia\u0026#34; click C href \u0026#34;https://www.wikipedia.org\u0026#34; \u0026#34;wikipedia\u0026#34; flowchart LR A[Google] B[Github] C[Wikipedia] A--\u0026gt;B--\u0026gt;C click A \u0026#34;https://www.google.com\u0026#34; \u0026#34;google\u0026#34; click A href \u0026#34;https://www.google.com\u0026#34; \u0026#34;google\u0026#34; click B \u0026#34;https://www.github.com\u0026#34; \u0026#34;github\u0026#34; click B href \u0026#34;https://www.github.com\u0026#34; \u0026#34;github\u0026#34; click C \u0026#34;https://www.wikipedia.org\u0026#34; \u0026#34;wikipedia\u0026#34; click C href \u0026#34;https://www.wikipedia.org\u0026#34; \u0026#34;wikipedia\u0026#34; 注释 flowchart LR %% 这是一段注释 %% 这是另一段注释 A[Google] B[Github] C[Wikipedia] A--\u0026gt;B--\u0026gt;C flowchart LR %% 这是一段注释 %% 这是另一段注释 A[Google] B[Github] C[Wikipedia] A--\u0026gt;B--\u0026gt;C ","permalink":"https://edinik.com/posts/tech/guide-to-using-mermaid-flowcharts/","summary":"一个节点 flowchart LR 北京 flowchart LR 北京 一个带文本的节点 flowchart LR 北京[北京是中国的首都] flowchart LR 北京[北京是中国的首都] 流程图方向 从左到右 flowchart LR 北京--\u0026gt;上海 flowchart LR 北京--\u003e上海 从右到左 flowchart RL 北京--\u0026gt;上海 flowchart RL 北京--\u003e上海 从上到下 flowchart TB 北京--\u0026gt;上海 flowchart TB 北京--\u003e上海 从下到上 flowchart BT 北京--\u0026g","title":"mermaid | 流程图"},{"content":" Edison\u0026#39;s Blog 一个记录技术、阅读、生活的博客 Peter\u0026#39;s Blog 累点滴技术，品百味人生。 👉友链格式 名称： Edison\u0026rsquo;s Blog 网址： https://edinik.com 图标： https://edinik.com/img/logo.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 ","permalink":"https://edinik.com/links/","summary":"Edison\u0026#39;s Blog 一个记录技术、阅读、生活的博客 Peter\u0026#39;s Blog 累点滴技术，品百味人生。 👉友链格式 名称： Edison\u0026rsquo;s Blog 网址： https://edinik.com 图标： https://edinik.com/img/logo.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内","title":"🤝 友链"},{"content":" 英文名: Edison Chu 职业: Software Engineer 爱好: 摄影、爬山、骑行 ","permalink":"https://edinik.com/about/","summary":"英文名: Edison Chu 职业: Software Engineer 爱好: 摄影、爬山、骑行","title":"🙋🏻‍♂️ 关于"},{"content":"C# 的 System.IO.Compression 命名空间中提供了 ZipArchive 类，它可以用于创建、打开和操作 ZIP 文件。下面是一些常见的用法示例：\n创建zip文件 要创建一个 ZIP 文件，需要使用 ZipArchive 类的构造函数来创建一个实例，并将其与输出流（例如文件流）相关联。然后使用 CreateEntry 方法在 ZIP 文件中添加条目。\nusing System.IO.Compression; using var stream = new FileStream(\u0026#34;example.zip\u0026#34;, FileMode.Create); using var zip = new ZipArchive(stream, ZipArchiveMode.Create); var entry = zip.CreateEntry(\u0026#34;example.txt\u0026#34;); using var writer = new StreamWriter(entry.Open()); writer.Write(\u0026#34;Hello world!\u0026#34;); 从zip文件中读取条目 要从 ZIP 文件中读取条目，需要使用 ZipArchive 类的构造函数来创建一个实例，并将其与输入流（例如文件流）相关联。然后使用 GetEntry 方法来获取条目，并使用 Open 方法来获取条目的输入流。\nusing System.IO.Compression; using var stream = new FileStream(\u0026#34;example.zip\u0026#34;, FileMode.Open); using var zip = new ZipArchive(stream, ZipArchiveMode.Read); foreach (var entry in zip.Entries) { Console.WriteLine($\u0026#34;Entry:{entry.FullName},Size:{entry.Length} bytes\u0026#34;); using var reader = new StreamReader(entry.Open()); Console.WriteLine(reader.ReadToEnd()); } 修改 zip 文件 要修改一个 ZIP 文件，可以使用 ZipArchive 类的 CreateEntry 方法创建新条目，或者使用 GetEntry 方法获取现有条目并修改其内容。可以使用 Delete 方法删除现有条目。\nusing System.IO.Compression; using var stream = new FileStream(\u0026#34;example.zip\u0026#34;, FileMode.OpenOrCreate); using var zip = new ZipArchive(stream, ZipArchiveMode.Update); // 添加一个新的条目 var entry1 = zip.CreateEntry(\u0026#34;new.txt\u0026#34;); using (var writer = new StreamWriter(entry1.Open())) { writer.Write(\u0026#34;This is a new file.\u0026#34;); } // 修改一个已存在的条目 var entry2 = zip.GetEntry(\u0026#34;example.txt\u0026#34;); if (entry2 != null) { using var writer = new StreamWriter(entry2.Open()); writer.Write(\u0026#34;This file has been modified.\u0026#34;); } // 删除一个已存在的条目 var entry3 = zip.GetEntry(\u0026#34;old.txt\u0026#34;); entry3?.Delete(); ","permalink":"https://edinik.com/posts/tech/usage-of-ziparchive-in-csharp/","summary":"C# 的 System.IO.Compression 命名空间中提供了 ZipArchive 类，它可以用于创建、打开和操作 ZIP 文件。下面是一些常见的用法示例： 创建zip文件 要创建一个 ZIP 文件，需要使用 ZipArchive 类的构造函数来创建一个实例，并将其与输出流（例如文件流）相关联。然后使用 CreateEntry 方法在 ZIP 文件中添加条目。 using System.IO.Compression; using var stream = new FileStream(\u0026#34;example.zip\u0026#34;, FileMode.Create); using var zip = new ZipArchive(stream, ZipArchiveMode.Create); var entry = zip.CreateEntry(\u0026#34;example.txt\u0026#34;); using var writer = new StreamWriter(entry.Open());","title":"csharp | ziparchive的用法"},{"content":"介绍 在C#编程中，string和StringBuilder是两种常用的字符串类型，它们在应用场景和性能上有着明显的差异。string是不可变的字符串类型，一旦创建就不能修改，因此它适用于需要频繁读取而不需要修改的场景；而StringBuilder是可变的字符串类型，可以在原有的字符串上进行修改，适用于需要频繁修改字符串的场景。\n本文将从定义、区别、应用场景和性能等方面介绍string和StringBuilder的差异，并进行性能比较，希望能够帮助读者更好地理解和应用这两种字符串类型\nstring和StringBuilder的基本概念 string string是C#中的一种不可变字符串类型，表示一个字符串对象，它存储在堆内存中。一旦创建了一个string对象，就不能修改它的值，而是创建一个新的string对象。这种不可变性带来了一些优点，例如更安全、更容易缓存、更容易共享等，但也带来了一些性能问题，例如频繁地创建和销毁对象会占用大量的内存和CPU时间。\nStringBuilder StringBuilder是C#中的一种可变字符串类型，表示一个字符串缓冲区，它也存储在堆内存中。与string不同，StringBuilder对象可以在原有的字符串缓冲区上进行修改，而不需要创建新的对象。因此，StringBuilder适用于需要频繁修改字符串的场景，例如字符串连接、替换、插入等。\n需要注意的是，StringBuilder对象是可变的，但不是线程安全的，因此在多线程环境下，需要采取措施来确保线程安全。可以使用锁或者使用ThreadLocal类创建多个StringBuilder对象，每个线程独立使用一个StringBuilder对象，以确保线程安全。\n区别 string和StringBuilder的定义和用法 在C#中，string和StringBuilder都是用于表示字符串的类型。它们的定义和用法有所不同：\nstring:\nstring str = \u0026#34;hello\u0026#34;; StringBuilder：\nStringBuilder sb = new StringBuilder(\u0026#34;hello\u0026#34;); string对象是不可变的，一旦创建了一个string对象，就不能修改它的值，而是创建一个新的string对象。StringBuilder对象是可变的，可以在原有的字符串缓冲区上进行修改，而不需要创建新的对象。\n内存分配和管理 string和StringBuilder的内存分配和管理方式也不同。\nstring对象的内存是在堆内存上分配的，它的生命周期由垃圾回收器控制。当string对象不再被引用时，它的内存将被垃圾回收器自动回收。\nStringBuilder对象也是在堆内存上分配的，但是它使用了可变大小的内部缓冲区。当StringBuilder对象的缓冲区不足以存储新的字符时，它会自动重新分配一个更大的缓冲区，同时将旧的缓冲区释放掉。这个过程会导致一定的性能开销，但是可以避免频繁创建和销毁对象，从而减少了内存压力。\n字符串连接和修改方式 string和StringBuilder的字符串连接和修改方式也不同。\n对于string对象，每次连接两个字符串时，都会创建一个新的string对象，这样会导致频繁地创建和销毁对象，从而占用大量的内存和CPU时间。\n例如：\nstring str = \u0026#34;hello\u0026#34;; str += \u0026#34; world\u0026#34;; 上述代码会创建两个string对象，一个是\u0026quot;hello\u0026quot;，另一个是\u0026quot; world\u0026quot;，然后再将它们连接起来，创建一个新的string对象\u0026quot;hello world\u0026quot;。这个过程中创建了三个string对象，即\u0026quot;hello\u0026quot;、\u0026quot; world\u0026quot;和\u0026quot;hello world\u0026quot;。\n对于StringBuilder对象，每次连接两个字符串时，它会在原有的字符串缓冲区上进行修改，而不需要创建新的对象。这样可以避免频繁地创建和销毁对象，从而减少了内存和CPU的开销。\n例如：\nStringBuilder sb = new StringBuilder(\u0026#34;hello\u0026#34;); sb.Append(\u0026#34; world\u0026#34;); 上述代码只创建了一个StringBuilder对象，然后在它的缓冲区上添加了一个新的字符串\u0026quot; world\u0026quot;，最终得到的字符串是\u0026quot;hello world\u0026quot;。这个过程中只创建了一个StringBuilder对象，没有创建任何新的string对象。\n总之，string适用于需要频繁读取而不需要修改的场景，而StringBuilder适用于需要频繁修改字符串的场景。需要根据实际的业务需求选择合适的字符串类型。\n应用场景 string的适用场景 string适用于需要频繁读取而不需要修改的场景，例如：\n字符串常量 字符串的比较、查找、截取等操作 字符串的格式化输出 例如：\nstring str1 = \u0026#34;hello\u0026#34;; // 字符串常量 string str2 = \u0026#34;world\u0026#34;; string str3 = str1 + \u0026#34; \u0026#34; + str2; // 字符串连接 if (str1.Equals(\u0026#34;hello\u0026#34;)) // 字符串比较 { Console.WriteLine(\u0026#34;str1 equals hello\u0026#34;); } string substr = str3.Substring(0, 5); // 字符串截取 Console.WriteLine(substr); string formatstr = string.Format(\u0026#34;str1={0}, str2={1}\u0026#34;, str1, str2); // 字符串格式化输出 Console.WriteLine(formatstr); StringBuilder的适用场景 StringBuilder适用于需要频繁修改字符串的场景，例如：\n大量字符串的连接 大量字符串的替换、插入等操作 例如：\nStringBuilder sb = new StringBuilder(\u0026#34;hello\u0026#34;); for (int i = 0; i \u0026lt; 10000; i++) { sb.Append(\u0026#34; world\u0026#34;); // 大量字符串的连接 } string str = sb.ToString(); Console.WriteLine(str); sb.Replace(\u0026#34;world\u0026#34;, \u0026#34;csharp\u0026#34;); // 大量字符串的替换 sb.Insert(0, \u0026#34;welcome to \u0026#34;); // 大量字符串的插入 string newstr = sb.ToString(); Console.WriteLine(newstr); 总之，需要根据实际的业务需求选择合适的字符串类型，避免不必要的性能开销。如果需要频繁修改字符串，建议使用StringBuilder，否则可以使用string。同时，对于大量的字符串操作，建议使用StringBuilder，可以避免频繁地创建和销毁string对象，提高性能。\n性能比较 对于字符串的操作，性能是一个非常重要的指标。下面通过实验对比string和StringBuilder的性能。\n实验方法 通过一个循环，分别使用string和StringBuilder对字符串进行10000次的连接操作，然后计算每次操作的耗时。具体代码如下：\nusing System; using System.Diagnostics; using System.Text; namespace StringTest { class Program { static void Main(string[] args) { // test string string str = \u0026#34;\u0026#34;; Stopwatch sw = new Stopwatch(); sw.Start(); for (int i = 0; i \u0026lt; 10000; i++) { str += \u0026#34;hello world\u0026#34;; } sw.Stop(); Console.WriteLine(\u0026#34;test string: \u0026#34; + sw.ElapsedMilliseconds + \u0026#34; ms\u0026#34;); // test StringBuilder StringBuilder sb = new StringBuilder(); sw.Reset(); sw.Start(); for (int i = 0; i \u0026lt; 10000; i++) { sb.Append(\u0026#34;hello world\u0026#34;); } sw.Stop(); Console.WriteLine(\u0026#34;test StringBuilder: \u0026#34; + sw.ElapsedMilliseconds + \u0026#34; ms\u0026#34;); } } } 比较结果 在我的机器上，运行以上代码，得到的实验结果如下：\ntest string: 235 ms test StringBuilder: 0 ms 可以看到，使用string进行字符串连接的耗时是235毫秒，而使用StringBuilder进行字符串连接的耗时只有0毫秒，相差非常明显。\n这是因为，string在进行字符串连接时，每次连接都会创建一个新的string对象，而原有的string对象则成为垃圾对象，需要进行垃圾回收。而StringBuilder则通过修改自身的内部缓冲区来进行字符串连接，避免了频繁创建和销毁string对象，因此速度更快。\n因此，对于大量字符串的连接操作，建议使用StringBuilder，可以显著提高性能。\n总结 本文介绍了C#编程中string和StringBuilder的区别、各自的应用场景和性能比较。\n可以看到，string适用于需要频繁读取而不需要修改的场景，例如字符串常量、比较、查找、截取、格式化输出等操作。而StringBuilder适用于需要频繁修改字符串的场景，例如大量字符串的连接、替换、插入等操作。\n在性能方面，使用string进行字符串连接的耗时是比较大的，而使用StringBuilder进行字符串连接的耗时则很小，可以显著提高性能。因此，对于大量字符串的连接操作，建议使用StringBuilder，避免不必要的性能开销。\n总之，根据实际的业务需求选择合适的字符串类型，可以有效地提高程序的性能和效率。\n参考文献 [1] Microsoft Docs. String Class. https://docs.microsoft.com/en-us/dotnet/api/system.string?view=net-6.0\n[2] Microsoft Docs. StringBuilder Class. https://docs.microsoft.com/en-us/dotnet/api/system.text.stringbuilder?view=net-6.0\n[3] C# Program Examples. Difference between String and StringBuilder in C#. https://www.c-sharpcorner.com/article/difference-between-string-and-stringbuilder-in-c-sharp/\n","permalink":"https://edinik.com/posts/tech/difference-between-string-and-stringbuilder-in-csharp/","summary":"介绍 在C#编程中，string和StringBuilder是两种常用的字符串类型，它们在应用场景和性能上有着明显的差异。string是不可变的字符串类型，一旦创建就不能修改，因此它适用于需要频繁读取而不需要修改的场景；而StringBuilder是可变的字符串类型，可以在原有的字","title":"csharp | string vs stringbuilder"}]