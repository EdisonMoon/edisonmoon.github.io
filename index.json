[{"content":"一个节点 flowchart LR 北京 flowchart LR 北京 一个带文本的节点 flowchart LR 北京[北京是中国的首都] flowchart LR 北京[北京是中国的首都] 流程图方向 从左到右 flowchart LR 北京--\u0026gt;上海 flowchart LR 北京--\u003e上海 从右到左 flowchart RL 北京--\u0026gt;上海 flowchart RL 北京--\u003e上海 从上到下 flowchart TB 北京--\u0026gt;上海 flowchart TB 北京--\u003e上海 从下到上 flowchart BT 北京--\u0026gt;上海 flowchart BT 北京--\u003e上海 节点样式 圆角节点 flowchart LR 北京(北京是中国的首都) flowchart LR 北京(北京是中国的首都) 半圆弧节点 flowchart LR 开始([开始]) flowchart LR 开始([开始流程]) 子流程节点 flowchart LR 子流程[[这是一个子流程]] flowchart LR 子流程[[这是一个子流程]] 圆柱形节点 flowchart LR 数据库[(数据库)] flowchart LR 数据库[(数据库)] 圆形节点 flowchart LR 圆形((这是一个圆形)) flowchart LR 圆形((这是一个圆形)) 非对称形状节点 flowchart LR 非对称形状\u0026gt;这是一个非对称形状] flowchart LR 非对称形状\u003e这是一个非对称形状] 菱形节点 flowchart LR 菱形{这是一个菱形} flowchart LR 菱形{这是一个菱形} 六边形节点 flowchart LR 六边形{{这是一个六边形}} flowchart LR 六边形{{这是一个六边形}} 平行四边形节点 flowchart LR 平行四边形[/这是一个平行四边形/] flowchart LR 平行四边形[/这是一个平行四边形/] flowchart LR 平行四边形[\\这是一个平行四边形\\] flowchart LR 平行四边形[\\这是一个平行四边形\\] 梯形节点 flowchart LR 梯形[/这是一个梯形\\] flowchart LR 梯形[/这是一个梯形\\] flowchart LR 梯形[\\这是一个梯形/] flowchart LR 梯形[\\这是一个梯形/] 双重圆环节点 flowchart LR 双重圆环(((这是一个双重圆环))) flowchart LR 双重圆环(((这是一个双重圆环))) 节点之间的链接 带箭头的链接 flowchart LR 北京--\u0026gt;上海 flowchart LR 北京--\u003e上海 开放的链接 flowchart LR 北京---上海 flowchart LR 北京---上海 链接上的文字 flowchart LR 北京---|G30|上海 flowchart LR 北京---|G30|上海 带有箭头和文本的链接 flowchart LR 北京--\u0026gt;|G30|上海 flowchart LR 北京--\u003e|G30|上海 虚线链接 flowchart LR 北京-.-\u0026gt;上海 flowchart LR 北京-.-\u003e上海 带文本的虚线链接 flowchart LR 北京-.-\u0026gt;|G30|上海 flowchart LR 北京-.-\u003e|G30|上海 加粗链接 flowchart LR 北京==\u0026gt;上海 flowchart LR 北京==\u003e上海 带文本的加粗链接 flowchart LR 北京==\u0026gt;|G30|上海 flowchart LR 北京==\u003e|G30|上海 链式链接 flowchart LR 北京--\u0026gt;上海--\u0026gt;广州 flowchart LR 北京--\u003e|G30|上海--\u003e|G40|广州 flowchart LR 北京--\u0026gt;上海 \u0026amp; 杭州--\u0026gt;广州 flowchart LR 北京--\u003e上海 \u0026 杭州--\u003e广州 flowchart LR 上海 \u0026amp; 杭州--\u0026gt;广州 \u0026amp; 深圳 flowchart TB 上海 \u0026 杭州--\u003e广州 \u0026 深圳 新型箭头链接 flowchart LR 北京 --o 上海 --x 广州 flowchart LR 北京 --o 上海 --x 广州 双向箭头 flowchart LR 北京\u0026lt;--\u0026gt;上海o--o广州x--x深圳 flowchart LR 北京 \u003c--\u003e 上海 o--o 广州 x--x 深圳 链接的最小长度 flowchart TB A[开始] --\u0026gt; B[输入用户名和密码] B --\u0026gt; C{认证成功 ?} C --\u0026gt;|是| D[登录成功] C --\u0026gt;|否| E[登录失败] D --\u0026gt; F[进入系统] F ----\u0026gt; I E --\u0026gt; G{是否重新登录 ?} G --\u0026gt;|是| B G --\u0026gt;|否| H[退出系统] H --\u0026gt; I[结束] flowchart TB A[开始] --\u003e B[输入用户名和密码] B --\u003e C{认证成功 ?} C --\u003e|是| D[登录成功] C --\u003e|否| E[登录失败] D --\u003e F[进入系统] F ----\u003e I E --\u003e G{是否重新登录 ?} G --\u003e|是| B G --\u003e|否| H[退出系统] H --\u003e I[结束] 特殊字符 flowchart LR A[\u0026#34;这是一个(括号)字符\u0026#34;] flowchart LR A[\"这是一个(括号)字符\"] 转义字符的代码 flowchart LR A[\u0026#34;这是一个双引号:#quot;\u0026#34;] --\u0026gt; B[\u0026#34;这是一个单引号:#39;\u0026#34;] --\u0026gt; C[\u0026#34;这是一个爱心:#9829;\u0026#34;] flowchart LR A[\"这是一个双引号:#quot;\"] --\u003e B[\"这是一个单引号:#39;\"] --\u003e C[\"这是一个爱心:#9829;\"] ","permalink":"https://blog.themostmoon.today/posts/tech/guide-to-using-mermaid-flowcharts/","summary":"一个节点 flowchart LR 北京 flowchart LR 北京 一个带文本的节点 flowchart LR 北京[北京是中国的首都] flowchart LR 北京[北京是中国的首都] 流程图方向 从左到右 flowchart LR 北京--\u0026gt;上海 flowchart LR 北京--\u003e上海 从右到左 flowchart RL 北京--\u0026gt;上海 flowchart RL 北京--\u003e上海 从上到下 flowchart TB 北京--\u0026gt;上海 flowchart TB 北京--\u003e上海 从下到上 flowchart BT 北京--\u0026g","title":"mermaid | 流程图"},{"content":" Edison\u0026#39;s Blog 一个记录技术、阅读、生活的博客 Peter\u0026#39;s Blog 累点滴技术，品百味人生。 👉友链格式 名称： Edison\u0026rsquo;s Blog 网址： https://blog.themostmoon.today 图标： https://blog.themostmoon.today/img/logo.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 ","permalink":"https://blog.themostmoon.today/links/","summary":"Edison\u0026#39;s Blog 一个记录技术、阅读、生活的博客 Peter\u0026#39;s Blog 累点滴技术，品百味人生。 👉友链格式 名称： Edison\u0026rsquo;s Blog 网址： https://blog.themostmoon.today 图标： https://blog.themostmoon.today/img/logo.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内","title":"🤝 友链"},{"content":" 英文名: Edison Chu 职业: 程序员 爱好: 摄影、爬山、骑行 ","permalink":"https://blog.themostmoon.today/about/","summary":"英文名: Edison Chu 职业: 程序员 爱好: 摄影、爬山、骑行","title":"🙋🏻‍♂️ 关于"},{"content":"C# 的 System.IO.Compression 命名空间中提供了 ZipArchive 类，它可以用于创建、打开和操作 ZIP 文件。下面是一些常见的用法示例：\n创建ZIP文件 要创建一个 ZIP 文件，需要使用 ZipArchive 类的构造函数来创建一个实例，并将其与输出流（例如文件流）相关联。然后使用 CreateEntry 方法在 ZIP 文件中添加条目。\nusing System.IO.Compression; using var stream = new FileStream(\u0026#34;example.zip\u0026#34;, FileMode.Create); using var zip = new ZipArchive(stream, ZipArchiveMode.Create); var entry = zip.CreateEntry(\u0026#34;example.txt\u0026#34;); using var writer = new StreamWriter(entry.Open()); writer.Write(\u0026#34;Hello world!\u0026#34;); 从ZIP文件中读取条目 要从 ZIP 文件中读取条目，需要使用 ZipArchive 类的构造函数来创建一个实例，并将其与输入流（例如文件流）相关联。然后使用 GetEntry 方法来获取条目，并使用 Open 方法来获取条目的输入流。\nusing System.IO.Compression; using var stream = new FileStream(\u0026#34;example.zip\u0026#34;, FileMode.Open); using var zip = new ZipArchive(stream, ZipArchiveMode.Read); foreach (var entry in zip.Entries) { Console.WriteLine($\u0026#34;Entry:{entry.FullName},Size:{entry.Length} bytes\u0026#34;); using var reader = new StreamReader(entry.Open()); Console.WriteLine(reader.ReadToEnd()); } 修改 ZIP 文件 要修改一个 ZIP 文件，可以使用 ZipArchive 类的 CreateEntry 方法创建新条目，或者使用 GetEntry 方法获取现有条目并修改其内容。可以使用 Delete 方法删除现有条目。\nusing System.IO.Compression; using var stream = new FileStream(\u0026#34;example.zip\u0026#34;, FileMode.OpenOrCreate); using var zip = new ZipArchive(stream, ZipArchiveMode.Update); // 添加一个新的条目 var entry1 = zip.CreateEntry(\u0026#34;new.txt\u0026#34;); using (var writer = new StreamWriter(entry1.Open())) { writer.Write(\u0026#34;This is a new file.\u0026#34;); } // 修改一个已存在的条目 var entry2 = zip.GetEntry(\u0026#34;example.txt\u0026#34;); if (entry2 != null) { using var writer = new StreamWriter(entry2.Open()); writer.Write(\u0026#34;This file has been modified.\u0026#34;); } // 删除一个已存在的条目 var entry3 = zip.GetEntry(\u0026#34;old.txt\u0026#34;); entry3?.Delete(); ","permalink":"https://blog.themostmoon.today/posts/tech/usage-of-ziparchive-in-csharp/","summary":"C# 的 System.IO.Compression 命名空间中提供了 ZipArchive 类，它可以用于创建、打开和操作 ZIP 文件。下面是一些常见的用法示例： 创建ZIP文件 要创建一个 ZIP 文件，需要使用 ZipArchive 类的构造函数来创建一个实例，并将其与输出流（例如文件流）相关联。然后使用 CreateEntry 方法在 ZIP 文件中添加条目。 using System.IO.Compression; using var stream = new FileStream(\u0026#34;example.zip\u0026#34;, FileMode.Create); using var zip = new ZipArchive(stream, ZipArchiveMode.Create); var entry = zip.CreateEntry(\u0026#34;example.txt\u0026#34;); using var writer = new StreamWriter(entry.Open());","title":"csharp | ziparchive的用法"},{"content":"第一原理 定义 用最小的人力成本，最大化地满足用户需求。\n属性 复杂性：数据、逻辑和算法 遵从性：接口和规范 可变性：需求变更、可扩展 不可见性：诊断工具、日志记录、性能监控 能力地图 整洁代码 易于阅读、理解和维护的高质量代码\n保持代码简洁清晰：使用有意义的变量名、函数名和注释，避免冗余代码和过度复杂化的逻辑结构。 遵循 SOLID 设计原则：将大型问题分解为小问题进行解决，单一职责原则、开放封闭原则等可以帮助提高代码的可扩展性和可维护性。 编写干净的函数：函数应该只做一件事情，并且要短小精悍，依据函数名称即可推断出其作用。 做好异常处理：处理和抛出异常时，需要清晰明确地说明问题所在，避免不必要的歧义和误解。 编写自动化测试：自动化测试可以帮助发现隐藏的问题和预防后续产生的问题，同时也可以增加代码的可靠性。 使用合适的代码结构：避免长文件、长函数、深层次嵌套等导致代码难以维护的问题，可以采用模块化、面向对象等方式来组织代码结构。 编程范式 面向对象编程：以类和对象为中心，通过定义类来描述对象的属性和方法。程序通过继承和多态等机制实现代码重用和扩展。 过程式编程：以过程为中心，程序按照顺序执行。通过编写一系列函数或过程来完成任务，并通过参数传递数据。 函数式编程：以函数为中心，程序没有共享状态，可以作为参数传递和返回值使用。函数式编程遵循函数应该只做一件事情的原则，可以帮助减少代码量和提高可读性。 设计原则 SOLID 单一职责原则（Single Responsibility Principle, SRP）：一个类或模块应该只有一个单一的职责，不要把太多的功能放到同一个类或模块中。 开闭原则（Open-Closed Principle, OCP）：软件实体（类、模块等）应该对扩展开放，对修改关闭，即通过扩展代码来实现新的功能，而不是直接修改代码。 里氏替换原则（Liskov Substitution Principle, LSP）：任何使用基类对象的地方，都应该能够使用其子类对象，子类对象不能影响父类对象的行为。 接口隔离原则（Interface Segregation Principle, ISP）：客户端不应该强制依赖它们不需要的接口，将一个大型的接口拆分成多个小接口，以符合单一职责原则。 依赖倒置原则（Dependency Inversion Principle, DIP）：高层模块不应该依赖低层模块，两者都应该依赖于抽象；抽象不应该依赖于具体实现。 DRY Don\u0026rsquo;t Repeat Yourself.\n相同的代码应该只存在于一个地方，不应该在多个地方重复出现。\n使用函数、方法或类来封装重复的代码片段，避免代码冗余。 使用变量、常量或配置文件来存储常用的值，避免重复输入相同的内容。 使用工具、库或框架来提供通用的功能，避免重复编写相同的代码。 YAGNI You Ain\u0026rsquo;t Gonna Need It\n没有必要编写不需要的代码，因为这会增加代码复杂性和维护成本。\n只编写当前需要的代码，避免预先设计和编写未来可能需要的代码。 避免过度设计和复杂化的代码结构，遵循 KISS 原则（Keep It Simple, Stupid）。 使用测试驱动开发（TDD）等方法进行开发，确保只编写需要的代码，并保证代码的质量和可靠性。 Hollywood Principle 也称为反转控制（Inversion of Control, IOC）\n来源于好莱坞电影工业。在好莱坞电影中，演员通常不会主动联系导演或制片人，而是等待他们的电话。因此，这个原则被形象地描述为“不要打电话给我们，我们会打电话给你”。\n基本思想是：让高层组件或框架控制低层组件的创建和使用，并在需要时向低层组件发出请求。\n使用依赖注入（Dependency Injection）或服务定位器（Service Locator）等技术，将低层组件的创建和配置交给高层组件或框架管理。 让低层组件只关注自己需要做的事情，并提供必要的接口和功能，让高层组件去调用和使用。 避免使用单例模式和静态变量等全局状态，避免组件之间产生紧密的耦合关系。 Program Against Abstraction 也被称为“反向抽象原则” (Reverse Abstraction Principle)\n基本思想是尽可能避免过度抽象和复杂化，只在需要时创建必要的抽象。\n遵循 YAGNI 原则，只编写当前需要的代码，而不是预测未来可能需要的代码。 避免过度设计和复杂化的代码结构，遵循 KISS 原则（Keep It Simple, Stupid）。 在需要创建抽象时，确保它们是真正需要的，并考虑是否有更简单的方式解决问题。 设计模式 创建型模式 通过提供一种实例化对象的机制来解决问题。\n工厂方法模式（Factory Method Pattern）：定义一个用于创建对象的接口，但让子类决定实例化哪个类。工厂方法模式让一个类的实例化延迟到其子类中。\n抽象工厂模式（Abstract Factory Pattern）：提供一个接口，用于创建与一组相关或相互依赖的对象，而无需指定它们的具体类。\n单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点以便于该实例被访问。\n建造者模式（Builder Pattern）：将一个复杂对象的构建过程和表示分离，使得同样的构建过程可以创建不同的表示。\n原型模式（Prototype Pattern）：使用原型实例来指定要创建对象的类型，通过复制这个原型来创建新对象。\n结构型模式 用于解决不同类之间接口的问题。\n适配器模式（Adapter Pattern）：将一个类的接口转换成客户端所期望的另一个接口。\n桥接模式（Bridge Pattern）：将抽象部分和它的实现分离开来，使它们可以独立变化。\n组合模式（Composite Pattern）：将对象组合成树形结构以表示“部分-整体”的层次结构，并使得用户对单个对象和组合对象的使用具有一致性。\n装饰器模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责，同时又不改变其结构。\n外观模式（Facade Pattern）：为一组复杂的子系统提供一个简单的接口。\n享元模式（Flyweight Pattern）：通过共享技术来有效地支持大量细粒度的对象。\n代理模式（Proxy Pattern）：为其他对象提供一种代理以控制对这个对象的访问。\n行为型模式 用于解决对象之间的通信和协作问题。\n观察者模式（Observer Pattern）：定义对象之间的一种一对多依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都得到通知并自动更新。\n策略模式（Strategy Pattern）：定义一组算法，将每个算法都封装起来，并使它们可以相互替换，从而使得算法可以独立于客户端而变化。\n命令模式（Command Pattern）：将请求封装成一个对象，从而允许你使用不同的请求、队列或日志请求参数化其他对象，同时也支持可撤销的操作。\n模板方法模式（Template Method Pattern）：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下重新定义算法中的某些步骤。\n迭代器模式（Iterator Pattern）：提供一种方法来访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。\n责任链模式（Chain of Responsibility Pattern）：为解除请求的发送者和接收者之间耦合，而使得多个对象都有机会处理请求。\n解释器模式（Interpreter Pattern）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。\n架构风格 分层架构（Layered Architecture）：将应用程序分成多个层次，每个层次执行单独的任务。每个层都只与相邻的层交互，从而实现松耦合。\n客户端-服务器（Client-Server）架构：客户端和服务器分别扮演不同的角色，客户端发送请求并等待响应，服务器接收请求并返回所需信息。\n事件驱动架构（Event-driven Architecture）：系统的各个部分通过发送和接收事件进行通信，从而实现松耦合。\n微服务架构（Microservices Architecture）：将应用程序拆分为一组小型的、自治的服务，每个服务都执行单独的业务逻辑。\n面向服务架构（Service-oriented Architecture，SOA）：用于构建分布式系统的一种方法，其中服务是应用程序之间松耦合的粒度。\n发布-订阅架构（Publish-Subscribe Architecture）：发布者发布消息，订阅者订阅消息并在发布时接收到通知。\n数据中心化架构（Data-Centered Architecture）：应用程序围绕一个中央数据存储器构建，所有操作都针对这个中央数据存储器。\n架构模式 MVC（Model-View-Controller）模式：将应用程序分为三个部分，模型负责数据存储和处理，视图负责呈现数据，控制器协调模型和视图之间的交互。\nMVP（Model-View-Presenter）模式：类似于MVC模式，但是视图与模型之间没有直接联系，而是通过一个中介者——Presenter进行交互。\nMVVM（Model-View-ViewModel）模式：在MVP模式的基础上进一步发展，引入了ViewModel作为视图和模型之间的桥梁，以支持数据绑定和声明式编程。\n事件驱动架构（EDA）模式：系统各个部分之间基于事件交互，使得系统更具可扩展性和灵活性。\nREST（Representational State Transfer）架构模式：一种基于HTTP协议的Web服务建设架构，包括客户机、服务器、资源、状态转换和统一接口等核心元素。\nCQRS（Command Query Responsibility Segregation）模式：将查询与命令分开处理，以提高系统性能和可扩展性。\n微内核架构模式：将系统的核心功能抽象出来，形成一个小型的微内核，其他非核心功能则被实现为插件，可以方便地添加或删除。\n质量属性 可维护性（Maintainability）：软件系统易于修改和调整，以使其在不断变化的需求下保持有效。\n可扩展性（Scalability）：软件系统能够应对日益增长的数据和功能需求，并且可以在需要时进行水平或垂直扩展。\n可靠性（Reliability）：软件系统提供了稳定、可靠、无故障的运行环境，以确保数据和业务流程的正确性和可靠性。\n安全性（Security）：软件系统提供了有效的安全措施来防范潜在的攻击和漏洞，以保护数据和系统免受未经授权的访问和使用。\n性能（Performance）：软件系统能够快速地响应用户请求，并能够在高负载情况下保持高效率。\n可用性（Usability）：软件系统易于理解、学习和使用，使用户能够有效地完成任务。\n易用性（Portability）：软件系统能够在不同的平台和环境中无缝运行，以支持跨越不同技术栈和设备的使用。\n工具箱 4+1视图 一种软件架构描述方法，由Philippe Kruchten于1995年提出。它包括四个逻辑视图和一个物理视图，用于描述软件系统的不同方面。\n逻辑视图（Logical View）：描述了系统的功能、对象、类或组件之间的关系。它强调系统的静态结构，通常用于描述系统的核心功能和服务。\n开发视图（Development View）：描述了系统如何被实现和开发，并涵盖了代码、测试、构建等方面。它强调软件的动态行为，对于开发人员和测试人员非常有用。\n进程视图（Process View）：描述了系统运行时组件之间的并发性、交互和通信。它强调系统的执行和部署，通常用于描述系统的可伸缩性和性能。\n物理视图（Physical View）：描述了系统的物理部署方式和组成，例如硬件、网络、服务器和存储等。它强调了系统所有的物理部件和环节之间的联系和互动。\n场景视图（Scenario View）：描述了系统在特定场景下的使用情况，例如用户与系统的互动、信息传输和交互。它强调了系统的功能和行为，可用于演示系统的功能和模拟使用场景。\nUML 一种用于软件系统分析、设计和实现的标准化建模语言。它提供了一组图形符号和规则，以便于开发人员进行沟通、协作和共享设计信息。\n用例图（Use Case Diagram）：描述系统的功能和行为，从用户的角度来看。\n类图（Class Diagram）：描述系统中类、接口和对象之间的关系，以及它们的属性和操作。\n对象图（Object Diagram）：描述一个特定时间点上的对象实例及其相互关系。\n活动图（Activity Diagram）：描述系统的流程和控制流，以及在这些流程中执行的活动。\n序列图（Sequence Diagram）：描述在系统中不同对象之间的交互和消息传递。\n通信图（Communication Diagram）：描述系统中对象之间的关系和交互。\n状态图（State Diagram）：描述系统中各个状态之间的转移条件和事件。\n部署图（Deployment Diagram）：描述系统部署的物理结构，例如服务器、计算机等。\nC4模型 一种简单的、可扩展的软件架构建模方法，由Simon Brown于2011年提出。它通过四个层次的架构视图，帮助开发人员更好地理解、描述和通信软件系统架构。\n上下文层（Context）：描述了软件系统与外部世界之间的关系和依赖关系。它使用上下文图来显示系统边界内外的各个参与者以及它们之间的交互方式。\n容器层（Container）：描述了软件系统中的主要组成部分和它们之间的关系。它使用容器图来显示系统的组件、服务和数据存储等，并且它们之间的关系和依赖关系。\n组件层（Component）：描述了各个容器中的具体实现和组件。它使用组件图来显示各个组件之间的关系、职责和接口，并补充说明它们如何协同工作以支持系统的功能。\n代码层（Code）：描述了各个组件的详细实现和构造。它使用类图或其他更详细的视图来显示各个类、接口和方法等。\n图表即代码 一种将图形化表示转换为可执行的、版本控制的代码的方法。它可以将描述系统架构和设计的不同类型的图形化表示，如流程图、序列图、状态图、组件图等，转换成可读性强、易于维护和扩展的代码。\nPlantUML：使用简单的文本语法来表示各种类型的图表，并将其转换为可执行的代码。\nMermaid：使用简单的文本语言来描述各种类型的图表，并将其转换为SVG图片。\nGraphviz：使用DOT语言来描述各种类型的图表，然后使用Graphviz的渲染引擎将其转换为可视化的图表。\n","permalink":"https://blog.themostmoon.today/posts/tech/architecture-design-patterns-principles/","summary":"第一原理 定义 用最小的人力成本，最大化地满足用户需求。 属性 复杂性：数据、逻辑和算法 遵从性：接口和规范 可变性：需求变更、可扩展 不可见性：诊断工具、日志记录、性能监控 能力地图 整洁代码 易于阅读、理解和维护的高质量代码 保持代码简洁清晰：使用有意义的变量名、函数名和注释，避免冗余代码和过度复","title":"架构设计 | 设计模式 \u0026 设计原则"},{"content":"介绍 在C#编程中，string和StringBuilder是两种常用的字符串类型，它们在应用场景和性能上有着明显的差异。string是不可变的字符串类型，一旦创建就不能修改，因此它适用于需要频繁读取而不需要修改的场景；而StringBuilder是可变的字符串类型，可以在原有的字符串上进行修改，适用于需要频繁修改字符串的场景。\n本文将从定义、区别、应用场景和性能等方面介绍string和StringBuilder的差异，并进行性能比较，希望能够帮助读者更好地理解和应用这两种字符串类型\nstring和StringBuilder的基本概念 string string是C#中的一种不可变字符串类型，表示一个字符串对象，它存储在堆内存中。一旦创建了一个string对象，就不能修改它的值，而是创建一个新的string对象。这种不可变性带来了一些优点，例如更安全、更容易缓存、更容易共享等，但也带来了一些性能问题，例如频繁地创建和销毁对象会占用大量的内存和CPU时间。\nStringBuilder StringBuilder是C#中的一种可变字符串类型，表示一个字符串缓冲区，它也存储在堆内存中。与string不同，StringBuilder对象可以在原有的字符串缓冲区上进行修改，而不需要创建新的对象。因此，StringBuilder适用于需要频繁修改字符串的场景，例如字符串连接、替换、插入等。\n需要注意的是，StringBuilder对象是可变的，但不是线程安全的，因此在多线程环境下，需要采取措施来确保线程安全。可以使用锁或者使用ThreadLocal类创建多个StringBuilder对象，每个线程独立使用一个StringBuilder对象，以确保线程安全。\n区别 string和StringBuilder的定义和用法 在C#中，string和StringBuilder都是用于表示字符串的类型。它们的定义和用法有所不同：\nstring:\nstring str = \u0026#34;hello\u0026#34;; StringBuilder：\nStringBuilder sb = new StringBuilder(\u0026#34;hello\u0026#34;); string对象是不可变的，一旦创建了一个string对象，就不能修改它的值，而是创建一个新的string对象。StringBuilder对象是可变的，可以在原有的字符串缓冲区上进行修改，而不需要创建新的对象。\n内存分配和管理 string和StringBuilder的内存分配和管理方式也不同。\nstring对象的内存是在堆内存上分配的，它的生命周期由垃圾回收器控制。当string对象不再被引用时，它的内存将被垃圾回收器自动回收。\nStringBuilder对象也是在堆内存上分配的，但是它使用了可变大小的内部缓冲区。当StringBuilder对象的缓冲区不足以存储新的字符时，它会自动重新分配一个更大的缓冲区，同时将旧的缓冲区释放掉。这个过程会导致一定的性能开销，但是可以避免频繁创建和销毁对象，从而减少了内存压力。\n字符串连接和修改方式 string和StringBuilder的字符串连接和修改方式也不同。\n对于string对象，每次连接两个字符串时，都会创建一个新的string对象，这样会导致频繁地创建和销毁对象，从而占用大量的内存和CPU时间。\n例如：\nstring str = \u0026#34;hello\u0026#34;; str += \u0026#34; world\u0026#34;; 上述代码会创建两个string对象，一个是\u0026quot;hello\u0026quot;，另一个是\u0026quot; world\u0026quot;，然后再将它们连接起来，创建一个新的string对象\u0026quot;hello world\u0026quot;。这个过程中创建了三个string对象，即\u0026quot;hello\u0026quot;、\u0026quot; world\u0026quot;和\u0026quot;hello world\u0026quot;。\n对于StringBuilder对象，每次连接两个字符串时，它会在原有的字符串缓冲区上进行修改，而不需要创建新的对象。这样可以避免频繁地创建和销毁对象，从而减少了内存和CPU的开销。\n例如：\nStringBuilder sb = new StringBuilder(\u0026#34;hello\u0026#34;); sb.Append(\u0026#34; world\u0026#34;); 上述代码只创建了一个StringBuilder对象，然后在它的缓冲区上添加了一个新的字符串\u0026quot; world\u0026quot;，最终得到的字符串是\u0026quot;hello world\u0026quot;。这个过程中只创建了一个StringBuilder对象，没有创建任何新的string对象。\n总之，string适用于需要频繁读取而不需要修改的场景，而StringBuilder适用于需要频繁修改字符串的场景。需要根据实际的业务需求选择合适的字符串类型。\n应用场景 string的适用场景 string适用于需要频繁读取而不需要修改的场景，例如：\n字符串常量 字符串的比较、查找、截取等操作 字符串的格式化输出 例如：\nstring str1 = \u0026#34;hello\u0026#34;; // 字符串常量 string str2 = \u0026#34;world\u0026#34;; string str3 = str1 + \u0026#34; \u0026#34; + str2; // 字符串连接 if (str1.Equals(\u0026#34;hello\u0026#34;)) // 字符串比较 { Console.WriteLine(\u0026#34;str1 equals hello\u0026#34;); } string substr = str3.Substring(0, 5); // 字符串截取 Console.WriteLine(substr); string formatstr = string.Format(\u0026#34;str1={0}, str2={1}\u0026#34;, str1, str2); // 字符串格式化输出 Console.WriteLine(formatstr); StringBuilder的适用场景 StringBuilder适用于需要频繁修改字符串的场景，例如：\n大量字符串的连接 大量字符串的替换、插入等操作 例如：\nStringBuilder sb = new StringBuilder(\u0026#34;hello\u0026#34;); for (int i = 0; i \u0026lt; 10000; i++) { sb.Append(\u0026#34; world\u0026#34;); // 大量字符串的连接 } string str = sb.ToString(); Console.WriteLine(str); sb.Replace(\u0026#34;world\u0026#34;, \u0026#34;csharp\u0026#34;); // 大量字符串的替换 sb.Insert(0, \u0026#34;welcome to \u0026#34;); // 大量字符串的插入 string newstr = sb.ToString(); Console.WriteLine(newstr); 总之，需要根据实际的业务需求选择合适的字符串类型，避免不必要的性能开销。如果需要频繁修改字符串，建议使用StringBuilder，否则可以使用string。同时，对于大量的字符串操作，建议使用StringBuilder，可以避免频繁地创建和销毁string对象，提高性能。\n性能比较 对于字符串的操作，性能是一个非常重要的指标。下面通过实验对比string和StringBuilder的性能。\n实验方法 通过一个循环，分别使用string和StringBuilder对字符串进行10000次的连接操作，然后计算每次操作的耗时。具体代码如下：\nusing System; using System.Diagnostics; using System.Text; namespace StringTest { class Program { static void Main(string[] args) { // test string string str = \u0026#34;\u0026#34;; Stopwatch sw = new Stopwatch(); sw.Start(); for (int i = 0; i \u0026lt; 10000; i++) { str += \u0026#34;hello world\u0026#34;; } sw.Stop(); Console.WriteLine(\u0026#34;test string: \u0026#34; + sw.ElapsedMilliseconds + \u0026#34; ms\u0026#34;); // test StringBuilder StringBuilder sb = new StringBuilder(); sw.Reset(); sw.Start(); for (int i = 0; i \u0026lt; 10000; i++) { sb.Append(\u0026#34;hello world\u0026#34;); } sw.Stop(); Console.WriteLine(\u0026#34;test StringBuilder: \u0026#34; + sw.ElapsedMilliseconds + \u0026#34; ms\u0026#34;); } } } 比较结果 在我的机器上，运行以上代码，得到的实验结果如下：\ntest string: 235 ms test StringBuilder: 0 ms 可以看到，使用string进行字符串连接的耗时是235毫秒，而使用StringBuilder进行字符串连接的耗时只有0毫秒，相差非常明显。\n这是因为，string在进行字符串连接时，每次连接都会创建一个新的string对象，而原有的string对象则成为垃圾对象，需要进行垃圾回收。而StringBuilder则通过修改自身的内部缓冲区来进行字符串连接，避免了频繁创建和销毁string对象，因此速度更快。\n因此，对于大量字符串的连接操作，建议使用StringBuilder，可以显著提高性能。\n总结 本文介绍了C#编程中string和StringBuilder的区别、各自的应用场景和性能比较。\n可以看到，string适用于需要频繁读取而不需要修改的场景，例如字符串常量、比较、查找、截取、格式化输出等操作。而StringBuilder适用于需要频繁修改字符串的场景，例如大量字符串的连接、替换、插入等操作。\n在性能方面，使用string进行字符串连接的耗时是比较大的，而使用StringBuilder进行字符串连接的耗时则很小，可以显著提高性能。因此，对于大量字符串的连接操作，建议使用StringBuilder，避免不必要的性能开销。\n总之，根据实际的业务需求选择合适的字符串类型，可以有效地提高程序的性能和效率。\n参考文献 [1] Microsoft Docs. String Class. https://docs.microsoft.com/en-us/dotnet/api/system.string?view=net-6.0\n[2] Microsoft Docs. StringBuilder Class. https://docs.microsoft.com/en-us/dotnet/api/system.text.stringbuilder?view=net-6.0\n[3] C# Program Examples. Difference between String and StringBuilder in C#. https://www.c-sharpcorner.com/article/difference-between-string-and-stringbuilder-in-c-sharp/\n","permalink":"https://blog.themostmoon.today/posts/tech/difference-between-string-and-stringbuilder-in-csharp/","summary":"介绍 在C#编程中，string和StringBuilder是两种常用的字符串类型，它们在应用场景和性能上有着明显的差异。string是不可变的字符串类型，一旦创建就不能修改，因此它适用于需要频繁读取而不需要修改的场景；而StringBuilder是可变的字符串类型，可以在原有的字","title":"csharp | string vs stringbuilder"}]