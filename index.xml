<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>EdisonLook</title>
    <link>https://blog.themostmoon.today/</link>
    <description>Recent content on EdisonLook</description>
    <image>
      <title>EdisonLook</title>
      <url>https://blog.themostmoon.today/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://blog.themostmoon.today/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 17 Mar 2023 15:04:00 +0800</lastBuildDate><atom:link href="https://blog.themostmoon.today/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>软件架构设计总结</title>
      <link>https://blog.themostmoon.today/architecture/concluding-thoughts-on-software-architecture-design/</link>
      <pubDate>Fri, 17 Mar 2023 15:04:00 +0800</pubDate>
      
      <guid>https://blog.themostmoon.today/architecture/concluding-thoughts-on-software-architecture-design/</guid>
      <description>第一原理 定义 用最小的人力成本，最大化地满足用户需求。
属性 复杂性：数据、逻辑和算法 遵从性：接口和规范 可变性：需求变更、可扩展 不可见性：诊断工具、日志记录、性能监控 能力地图 整洁代码 易于阅读、理解和维护的高质量代码
保持代码简洁清晰：使用有意义的变量名、函数名和注释，避免冗余代码和过度复杂化的逻辑结构。 遵循 SOLID 设计原则：将大型问题分解为小问题进行解决，单一职责原则、开放封闭原则等可以帮助提高代码的可扩展性和可维护性。 编写干净的函数：函数应该只做一件事情，并且要短小精悍，依据函数名称即可推断出其作用。 做好异常处理：处理和抛出异常时，需要清晰明确地说明问题所在，避免不必要的歧义和误解。 编写自动化测试：自动化测试可以帮助发现隐藏的问题和预防后续产生的问题，同时也可以增加代码的可靠性。 使用合适的代码结构：避免长文件、长函数、深层次嵌套等导致代码难以维护的问题，可以采用模块化、面向对象等方式来组织代码结构。 编程范式 面向对象编程：以类和对象为中心，通过定义类来描述对象的属性和方法。程序通过继承和多态等机制实现代码重用和扩展。 过程式编程：以过程为中心，程序按照顺序执行。通过编写一系列函数或过程来完成任务，并通过参数传递数据。 函数式编程：以函数为中心，程序没有共享状态，可以作为参数传递和返回值使用。函数式编程遵循函数应该只做一件事情的原则，可以帮助减少代码量和提高可读性。 设计原则 SOLID 单一职责原则（Single Responsibility Principle, SRP）：一个类或模块应该只有一个单一的职责，不要把太多的功能放到同一个类或模块中。 开闭原则（Open-Closed Principle, OCP）：软件实体（类、模块等）应该对扩展开放，对修改关闭，即通过扩展代码来实现新的功能，而不是直接修改代码。 里氏替换原则（Liskov Substitution Principle, LSP）：任何使用基类对象的地方，都应该能够使用其子类对象，子类对象不能影响父类对象的行为。 接口隔离原则（Interface Segregation Principle, ISP）：客户端不应该强制依赖它们不需要的接口，将一个大型的接口拆分成多个小接口，以符合单一职责原则。 依赖倒置原则（Dependency Inversion Principle, DIP）：高层模块不应该依赖低层模块，两者都应该依赖于抽象；抽象不应该依赖于具体实现。 DRY Don&amp;rsquo;t Repeat Yourself.
相同的代码应该只存在于一个地方，不应该在多个地方重复出现。
使用函数、方法或类来封装重复的代码片段，避免代码冗余。 使用变量、常量或配置文件来存储常用的值，避免重复输入相同的内容。 使用工具、库或框架来提供通用的功能，避免重复编写相同的代码。 YAGNI You Ain&amp;rsquo;t Gonna Need It
没有必要编写不需要的代码，因为这会增加代码复杂性和维护成本。
只编写当前需要的代码，避免预先设计和编写未来可能需要的代码。 避免过度设计和复杂化的代码结构，遵循 KISS 原则（Keep It Simple, Stupid）。 使用测试驱动开发（TDD）等方法进行开发，确保只编写需要的代码，并保证代码的质量和可靠性。 Hollywood Principle 也称为反转控制（Inversion of Control, IOC）</description>
    </item>
    
    <item>
      <title>探究C#编程中string和StringBuilder的区别、各自的应用场景和性能比较</title>
      <link>https://blog.themostmoon.today/csharp/difference-between-string-and-stringbuilder-in-csharp/</link>
      <pubDate>Fri, 17 Mar 2023 12:41:22 +0800</pubDate>
      
      <guid>https://blog.themostmoon.today/csharp/difference-between-string-and-stringbuilder-in-csharp/</guid>
      <description>1、介绍 在C#编程中，string和StringBuilder是两种常用的字符串类型，它们在应用场景和性能上有着明显的差异。string是不可变的字符串类型，一旦创建就不能修改，因此它适用于需要频繁读取而不需要修改的场景；而StringBuilder是可变的字符串类型，可以在原有的字符串上进行修改，适用于需要频繁修改字符串的场景。
本文将从定义、区别、应用场景和性能等方面介绍string和StringBuilder的差异，并进行性能比较，希望能够帮助读者更好地理解和应用这两种字符串类型
2、string和StringBuilder的基本概念 string string是C#中的一种不可变字符串类型，表示一个字符串对象，它存储在堆内存中。一旦创建了一个string对象，就不能修改它的值，而是创建一个新的string对象。这种不可变性带来了一些优点，例如更安全、更容易缓存、更容易共享等，但也带来了一些性能问题，例如频繁地创建和销毁对象会占用大量的内存和CPU时间。
StringBuilder StringBuilder是C#中的一种可变字符串类型，表示一个字符串缓冲区，它也存储在堆内存中。与string不同，StringBuilder对象可以在原有的字符串缓冲区上进行修改，而不需要创建新的对象。因此，StringBuilder适用于需要频繁修改字符串的场景，例如字符串连接、替换、插入等。
需要注意的是，StringBuilder对象是可变的，但不是线程安全的，因此在多线程环境下，需要采取措施来确保线程安全。可以使用锁或者使用ThreadLocal类创建多个StringBuilder对象，每个线程独立使用一个StringBuilder对象，以确保线程安全。
3、区别 string和StringBuilder的定义和用法 在C#中，string和StringBuilder都是用于表示字符串的类型。它们的定义和用法有所不同：
string:
string str = &amp;#34;hello&amp;#34;; StringBuilder：
StringBuilder sb = new StringBuilder(&amp;#34;hello&amp;#34;); string对象是不可变的，一旦创建了一个string对象，就不能修改它的值，而是创建一个新的string对象。StringBuilder对象是可变的，可以在原有的字符串缓冲区上进行修改，而不需要创建新的对象。
内存分配和管理 string和StringBuilder的内存分配和管理方式也不同。
string对象的内存是在堆内存上分配的，它的生命周期由垃圾回收器控制。当string对象不再被引用时，它的内存将被垃圾回收器自动回收。
StringBuilder对象也是在堆内存上分配的，但是它使用了可变大小的内部缓冲区。当StringBuilder对象的缓冲区不足以存储新的字符时，它会自动重新分配一个更大的缓冲区，同时将旧的缓冲区释放掉。这个过程会导致一定的性能开销，但是可以避免频繁创建和销毁对象，从而减少了内存压力。
字符串连接和修改方式 string和StringBuilder的字符串连接和修改方式也不同。
对于string对象，每次连接两个字符串时，都会创建一个新的string对象，这样会导致频繁地创建和销毁对象，从而占用大量的内存和CPU时间。
例如：
string str = &amp;#34;hello&amp;#34;; str += &amp;#34; world&amp;#34;; 上述代码会创建两个string对象，一个是&amp;quot;hello&amp;quot;，另一个是&amp;quot; world&amp;quot;，然后再将它们连接起来，创建一个新的string对象&amp;quot;hello world&amp;quot;。这个过程中创建了三个string对象，即&amp;quot;hello&amp;quot;、&amp;quot; world&amp;quot;和&amp;quot;hello world&amp;quot;。
对于StringBuilder对象，每次连接两个字符串时，它会在原有的字符串缓冲区上进行修改，而不需要创建新的对象。这样可以避免频繁地创建和销毁对象，从而减少了内存和CPU的开销。
例如：
StringBuilder sb = new StringBuilder(&amp;#34;hello&amp;#34;); sb.Append(&amp;#34; world&amp;#34;); 上述代码只创建了一个StringBuilder对象，然后在它的缓冲区上添加了一个新的字符串&amp;quot; world&amp;quot;，最终得到的字符串是&amp;quot;hello world&amp;quot;。这个过程中只创建了一个StringBuilder对象，没有创建任何新的string对象。
总之，string适用于需要频繁读取而不需要修改的场景，而StringBuilder适用于需要频繁修改字符串的场景。需要根据实际的业务需求选择合适的字符串类型。
4、应用场景 string的适用场景 string适用于需要频繁读取而不需要修改的场景，例如：
字符串常量 字符串的比较、查找、截取等操作 字符串的格式化输出 例如：
string str1 = &amp;#34;hello&amp;#34;; // 字符串常量 string str2 = &amp;#34;world&amp;#34;; string str3 = str1 + &amp;#34; &amp;#34; + str2; // 字符串连接 if (str1.</description>
    </item>
    
  </channel>
</rss>
